# Current situation about monads - モナドの現事情

## モナドを使うべきか？

使わないとコードが複雑になる、あるいはそうと予測される場合以外には使うべきではない。

また、モナドを使わないで一度コードを書いてみれば使うべきモナドが分かりやすくなる。

## 具体的なモナドを使うべきか？　それとも型クラスで一般化するか？

アプリケーションであるかライブラリであるかによって異なる。アプリケーションの場合は具体的なモナドを使うべきである。ライブラリである場合は型クラスで一般化するべきである。

アプリケーションでは変更が激しく、またコードの一般性もない。そのような場合に専用の型クラスを作っても、実際は一つの具体的なモナドだけが前提になりがちで、型クラスが肥大化しやすい。

ライブラリでは変更が少なく、コードに十分な一般性が確保されている。その一般性をさらに高めるためにモナドを型クラスで一般化するべきである。

## 単純なモナド（ Prelude に含まれているモナド）を使うべきか？

ライブラリでは使うべきではない。型クラスで一般化すべきである。

アプリケーションで全体的に使いたい場合は、それが IO モナドではないなら使うべきではない。確実に表現できる作用が不足する。

関数の内部実装など、アプリケーションかライブラリか問わずに局所的に使いたい場合は使ってもよい。

## モナド変換子は使うべきか？

これは具体的なモナドである。ライブラリでは使うべきではない。型クラスで一般化すべきである。

アプリケーションでも全体的には使うべきではない。モナド変換子には、型クラスのインスタンスが二次関数的に増加する、モナドの積み重ねの順番を考慮しなけれはならないなどの問題がある。代わりに ReaderT e IO パターン（RIOパターン）などを検討する。

アプリケーションでもライブラリでも関数の内部実装などの一部分でなら使ってもよい。局所的かつ、一段重ねだけならば許容範囲である。例えば StateT s IO や RWST r w s Identity などである。一方で StateT s (ExceptT e Identity) は許容範囲外である。

## どの型クラスを使うべきか？

MonadIO や MonadUnliftIO は使うべきである。 MonadIO は言わずもがな、 MonadUnliftIO もこれまでは一般化できなかった関数も一般化できる。

MonadBaseControl も使うべきである。少々特殊かもしれないが、 MobadUnliftIO と同様にモナドの階層を取り除くという操作についてうまく一般化できる。

これは難しいので https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/ という記事を読むことをお勧めする。

MonadThrow や MonadCatch や MonadMask も使うべきである。例外についてうまく取り扱うことができるのを一般化できる。

MonadPlus や MonadFix や MonadFail も使うべきだろう。それぞれ、普通のモナドから踏み出した作用を表現できる。

さて、普通の作用を表す MonadState や MonadReader や MonadWriter は使うべきであろうか。使うべきではない。使うとしても重複させてはいけない。それらはモナド変換子を前提としてしまっているからだ。

## Free モナドや Operational モナドを使うべきか？

厳密に作用を限定したい場合だけに使うべきである。そのような場合は、金融や数理などの大規模なアプリケーションで厳密さが要求されているといった場合が多い。モデル化のコストが支払えない場合は使うべきではない。IOモナドのサブセットとしての使用方法は身近で魅力的であるがコストに見合わない。

さらに、このままでは柔軟性がない。よって上に挙げた用途の場合は Extensible Effect などが実際には使われるだろう。

## Extensible Effect を使うべきか？

繰り返しになるが、厳密に作用を限定したい場合だけに使うべきである。そのような場合は、金融や数理などの大規模なアプリケーションで厳密さが要求されているといった場合が多い。モデル化のコストが支払えない場合は使うべきではない。IOモナドのサブセットとしての使用方法は魅力的であるがコストに見合わない。

対抗馬として record of functions などが挙げられるが、 Extensible Effect の魅力的な部分は a -> b -> ... m z という形に縛られず、また後付けで様々な実行ができることである。これは records of function では、おそらく基底モナドを Extensible Effect によって組み立てることでしか実現できない。

## record of functions を使うべきか？

知識がないのでわからない。

## RIOパターンを使うべきか？

ライブラリでは、IOを積極的に扱うライブラリなら検討できるだろう。

アプリケーションでは、全体の作用を扱うモナドとして使うべきである。局所的な場合では正しい回答とは限らない（ yesod の内部で Writer モナドを使った場合や、 fumieval 氏が状態が失敗によって初期化されることを期待して StateT s IO を使った場合もある）が、全体の作用を扱う場合は強力な手段となる。
