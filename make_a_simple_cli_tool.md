# make a simple cli tool

yhseq 、バージョン 3.0 を実装するのはとても困難な道になりそうなので、先にコマンド部分を作成することにした。

optparse-applicative 始めた。 Hackage の英語を読めば大体理解できる。初めは long で長い方を short で短い方を metavar で変数を help で説明を、それらをモノイドで合成して関数を掛けてオプションを作成。

option の順序は関係ない。そのために applicative を使っている。並行にできるから。モナドではダメ。

alternative も使える。両立しないオプションに使える。

なぜか Parser を ParserInfo に変えなければならない。

オプションのビルダーにも色々ある。普通は文字列になる。オプションがあるかどうかのプール型もある。また option auto で read 型クラスを使える。

フラグも使える。二つの値を渡して、どちらかの選択。これは switch つまり前の段落と同じみたいのになる。あと many と組み合わせてオプションの数を、数えることもできる。

引数ももちろんある。あと some や many と組み合わせて不定数も。あと -- の後は必ず引数でなければならない。

特に注目なのが command で、サブコマンドを司る。

https://hackage.haskell.org/package/optparse-applicative-0.15.1.0

読んだのは、ここの Builder の最後まで

# Haskell で簡単な CLI ツールを作ってみる

Haskell Advent Calendar 2019 の八日目は「 Haskell で簡単な CLI ツールを作ってみる」です。

さて、このタイトルで内容は想像しづらいかと思いますが、この記事では内部の実装は既に終わっていると仮定しています。その上で、コマンドの引数はどのようにすれば受け取れるのか、オプションを作るためにはどうすればいいのか、簡単に紹介していく記事になります。

## Step 1

`foo :: [Integer] -> Integer -> [Integer]` という関数が用意されています。これを使って以下のようなコマンドを作ります。

```
$ foo-simple [1,2] 3
[1,1,1,1]

$ foo-simple [1,2,3] 3
[1,2,2,2,2]
```

つまり、与えられた二つの引数を `foo` に与えて、その返り値を表示するだけのコマンドです。引数の数が合わないときはエラーとしましょう。

`Prelude` モジュール以外の関数で使う必要があるのは一つだけです。それは、引数を取ってくる作用を持つもの `getArgs` です。この関数が含まれているモジュールは `System.Environment` です。なので、インポートリストに書いておきましょう。

```haskell
module Main where

  import Prelude
  import System.Environment (getArgs)

  import Foo (foo)

  main :: IO ()
  main = do
    args <- getArgs
    print $ case args of
      [seq, num] -> foo (read seq) (read num)
      _ -> error "The arguments are incorrect!"
```

`getArgs` の型は `IO [String]` です。このプログラムをコンパイルして以下のように実行したとき、このプログラム内の `args` の値は以下のようになります。

```
./foo                     ==> []
./foo 1                   ==> ["1"]
./foo 1 2                 ==> ["1","2"]
./foo [1,2] 3             ==> ["[1,2]","3"]
./foo "foo foo" 'baa baa' ==> ["foo foo","baa baa"]
```

単純にコマンドラインの引数ですね。

そして、得られたリストにパターンマッチします。この時、引数の数が合わなければエラーとします。合っていれば `foo` に引数を渡しますが、このとき文字列からそれぞれのあるべき型の値に変換する必要があります。それには、 `read` を使います。そして、 `foo` の値を `print` して終わりです。

注意しておくと、ここで `read` を使いましたが、この関数には罠があります。例えば、 `f x = show (read x)` と関数を定義したとき、コンパイルエラーになります。それは `read` でどのような型と見なして読むかコンパイラに判断できないからです。しかし、ここでは `foo` により既に型が確定していますので問題ありません。

ここまでは導入です。なので、ここまでを単体として見て、このプログラミングスタイルは初心者にはわかりにくいのではといった指摘はご容赦お願いします。
